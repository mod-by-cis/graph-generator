# PROJEKT GRAPH-GENERATOR 

- @file ./CODE.md
- @author https://github.com/j-Cis 
- @lastmodified 2025-06-12T14:06:10.536Z+02:00

```
graph-generator/
│
├── .github/
│   │
│   └── workflows/
│       └── docs-build.yml                    // ## 0.
│
├── .vscode/
│   └── settings.json                         
│
├── docs/
│   │
│   ├── css/
│   │   │
│   │   ├── ui/
│   │   │   └── AccordionFields.css           // ## 6.
│   │   ├── main.css                          // ## 7.
│   │   └── reset.css                         // ## 5.
│   │
│   ├── dev/
│   │   │
│   │   ├── core/
│   │   │   └── state-accordion.ts            // ## 10.a 
│   │   │
│   │   ├── pages/
│   │   │   ├── AboutThis.tsx                 // ## 11.a.
│   │   │   ├── DotInsert.tsx                 // ## 11.e.
│   │   │   ├── DotRender.tsx                 // ## 11.f.
│   │   │   ├── DotWriter.tsx                 // ## 11.d.
│   │   │   ├── EduDot.tsx                    // ## 11.c.
│   │   │   └── EduGraphs.tsx                 // ## 11.b.
│   │   │
│   │   ├── style/
│   │   │   └── types.ts                      // ## 8.         
│   │   │
│   │   ├── ui/
│   │   │   ├── AccordionField.tsx            // ## 10.b.
│   │   │   ├── AccordionFields.tsx           // ## 10.c.
│   │   │   └── AccordionFieldsPilot.tsx      // ## 10.d.
│   │   └── main.tsx                          // ## 9.
│   │
│   ├── gen/
│   │   ├── lastBuild.txt
│   │   ├── main.js
│   │   ├── main.js.map
│   │   └── meta.json
│   └── index.html                            // ## 4.
│
├── tasks/
│   │
│   ├── utils/
│   │   ├── get-date-iso.ts                   
│   │   └── get-structure.ts                  
│   ├── docs-build.ts                         // ## 2.
│   └── docs-serve.ts                         // ## 3.
│
├── CODE_2025-06-12_16-38.md
├── deno.jsonc                                // ## 1.
├── deno.lock 
└── README.md
```

Poniżej znajduje się lista wszystkich plików projektu wraz z datą ich ostatniej modyfikacji, zgodnie z przekazanymi danymi.

| Ścieżka Pliku                               | Ostatnia Modyfikacja (`@lastmodified`) |
|---------------------------------------------|----------------------------------------|
| **Automatyzacja i Konfiguracja**            |                                        |
| `./.github/workflows/docs-build.yml`        | `2025-06-12T13:33:51.178Z+02:00`       |
| `./deno.jsonc`                              | `2025-06-12T13:57:47.083Z+02:00`       |
| `./tasks/docs-build.ts`                     | `2025-06-12T13:04:37.531Z+02:00`       |
| `./tasks/docs-serve.ts`                     | `2025-06-12T13:02:17.500Z+02:00`       |
| **Struktura Aplikacji (`/docs`)**           |                                        |
| `./docs/index.html`                         | `2025-06-12T13:08:51.934Z+02:00`       |
| `./docs/css/reset.css`                      | `2025-06-12T13:10:25.270Z+02:00`       |
| `./docs/css/main.css`                       | `2025-06-12T13:12:07.028Z+02:00`       |
| `./docs/css/ui/AccordionFields.css`         | `2025-06-12T13:13:11.138Z+02:00`       |
| **Kod Źródłowy (`/docs/dev`)**              |                                        |
| `./docs/dev/main.tsx`                       | `2025-06-12T13:15:20.370Z+02:00`       |
| `./docs/dev/style/types.ts`                 | `2025-06-12T13:16:36.109Z+02:00`       |
| `./docs/dev/core/state-accordion.ts`        | `2025-06-12T13:19:01.961Z+02:00`       |
| **Komponenty UI (`/docs/dev/ui`)**          |                                        |
| `./docs/dev/ui/AccordionField.tsx`          | `2025-06-12T13:20:17.608Z+02:00`       |
| `./docs/dev/ui/AccordionFields.tsx`         | `2025-06-12T13:21:12.598Z+02:00`       |
| `./docs/dev/ui/AccordionFieldsPilot.tsx`    | `2025-06-12T13:23:07.062Z+02:00`       |
| **Komponenty Stron (`/docs/dev/pages`)**    |                                        |
| `./docs/dev/pages/AboutThis.tsx`            | `2025-06-12T13:28:31.401Z+02:00`       |
| `./docs/dev/pages/DotInsert.tsx`            | `2025-06-12T13:29:20.880Z+02:00`       |
| `./docs/dev/pages/DotRender.tsx`            | `2025-06-12T13:29:58.528Z+02:00`       |
| `./docs/dev/pages/DotWriter.tsx`            | `2025-06-12T13:30:39.314Z+02:00`       |
| `./docs/dev/pages/EduDot.tsx`               | `2025-06-12T13:31:24.942Z+02:00`       |
| `./docs/dev/pages/EduGraphs.tsx`            | `2025-06-12T13:31:53.000Z+02:00`       |

----

## 0. @file ./.github/workflows/docs-build.yml

```yml
# 
# @file ./.github/workflows/docs-build.yml
# @author https://github.com/j-Cis
# 
# @lastmodified 2025-06-12T13:33:51.178Z+02:00
# @description automatyzacja github.
#


# Nazwa przepływu pracy
name: Build and Commit Docs

on:
  push:
    branches:
      - main # Uruchom tylko dla gałęzi main
    paths:
      # Uruchom, jeśli zmienią się pliki źródłowe...
      - 'docs/dev/**/*.ts'
      - 'docs/dev/**/*.tsx'
      # ...lub skrypt budujący...
      - 'tasks/docs-build.ts' 
      # ...lub konfiguracja Deno.
      - 'deno.jsonc'    

  # Umożliwia ręczne uruchomienie z zakładki Actions
  workflow_dispatch:

# Nadajemy uprawnienia do zapisu (commit/push) dla całego workflow
permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      # Krok 1: Pobranie kodu
      - name: Checkout repository
        uses: actions/checkout@v4

      # Krok 2: Ustawienie Deno
      - name: Setup Deno
        uses: denoland/setup-deno@v2 # Zgodnie z https://github.com/denoland/setup-deno
        with:
          deno-version: v2.3.5 # wersja Deno

      # Krok 3: Uruchomienie zadania z deno.jsonc
      - name: Run build task
      # run: deno run -A ./tasks/docs-build.ts # Użyj -A lub określ konkretne uprawnienia
        run: deno task gen # Bardziej idiomatyczne i zintegrowane z deno.jsonc
      
      # Krok 4: Commit i push zmian
      - name: Commit and push changes
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "ci: auto-build main.js of docs"
          
          # Wszystkie pliki podajemy jako jedną, wieloliniową listę
          file_pattern: |
            docs/gen/main.js
            docs/gen/main.js.map
            docs/gen/lastBuild.txt
            docs/gen/meta.json
            
          # Opcjonalnie, dla lepszej czytelności historii Git
          commit_user_name: GitHub Actions Bot
          commit_user_email: github-actions-bot@github.com
          # Akcja domyślnie commituje na gałąź, która wywołała workflow.
```

## 1. @file ./deno.jsonc

```json
// 
// @file ./deno.jsonc
// @author https://github.com/j-Cis
// 
// @lastmodified 2025-06-12T13:57:47.083Z+02:00
// @description Plik konfiguracyjny projektu DENO@2.3.5
// 

{
  "tasks": {
    "web": "deno run --allow-net --allow-read --watch ./tasks/docs-serve.ts",
    "gen": "deno run --allow-read --allow-write --allow-net --allow-env --allow-run ./tasks/docs-build.ts",
    "u:t": "deno run ./tasks/utils/get-date-iso.ts",
    "u:f": "deno run --allow-read ./tasks/utils/get-structure.ts"    
  },
  "compilerOptions": {
    "jsx": "react-jsx",
    "jsxImportSource": "preact",
    "strict": true,
    "lib": [
      "deno.ns",
      "deno.window",
      "deno.unstable",
      "deno.worker",
      "dom.asynciterable",
      "dom",
      "dom.iterable",
      "esnext",
      "es2024"
    ]
  },
  "imports": {
    "$esbuild": "https://deno.land/x/esbuild@v0.25.5",
    "$esbuild/": "https://deno.land/x/esbuild@v0.25.5/",
    "$esbuild-deno": "jsr:@luca/esbuild-deno-loader@^0.11.1",
    "$deno-http": "jsr:@std/http@^1.0.17",
    "$deno-path": "jsr:@std/path@^1.1.0",
    "$tsx-preact": "https://esm.sh/preact@10.26.8",
    "$tsx-preact/": "https://esm.sh/preact@10.26.8/",
    "$tsx-preact-signal": "https://esm.sh/@preact/signals@2.2.0",
    "$tsx-preact-signal/": "https://esm.sh/@preact/signals@2.2.0/",
    "$byCIS-read-structure-dir": "https://raw.githubusercontent.com/mod-by-cis/read-structure-dir/refs/tags/v0.1.1/mod.ts"
  }
}

```

## 2. @file ./tasks/docs-build.ts

```ts
/**
 * @file ./tasks/docs-build.ts
 * @author https://github.com/j-Cis
 * 
 * @lastmodified 2025-06-12T13:04:37.531Z+02:00
 * @description Budowanie wydania.
 */
import * as esbuild from "$esbuild/mod.js";
import { denoPlugins } from "$esbuild-deno";
import { fromFileUrl, join } from "$deno-path";

console.log("🚀 Rozpoczynam budowanie projektu...");
console.time("✅ Projekt zbudowany w");

// Ta logika jest nam potrzebna TYLKO do znalezienia pliku deno.jsonc
const projectDeno = join(fromFileUrl(new URL("../", import.meta.url)), "deno.jsonc");


try {
  const result = await esbuild.build({
    entryPoints: ["docs/dev/main.tsx"],
    outfile: "docs/gen/main.js", 
    // Dodajemy wtyczkę, która nauczy esbuild obsługiwać Deno
    plugins: [...denoPlugins({
        // Wskazujemy ścieżkę do pliku konfiguracyjnego, aby wtyczka znalazła Import Map
        configPath: projectDeno
    })],
    bundle: true,
    format: "esm",
    minify: true,
    metafile: true,
    sourcemap: true, //"inline",
    target: ["esnext"],
    // preact
    jsx: "automatic",
    jsxImportSource: "preact",
    loader: { ".ts": "ts", ".tsx": "tsx" },
    logLevel: "info",
    // pure: ['console.log', 'console.warn'],
  });

  console.timeEnd("✅ Projekt zbudowany w");
  if (result.metafile) {
    // Używamy JSON.stringify z dodatkowymi argumentami, aby plik był czytelny
    await Deno.writeTextFile("docs/gen/meta.json", JSON.stringify(result.metafile, null, 2));
    console.log(`✅ Plik metafile został zapisany w: ${"docs/gen/meta.json"}`);
  }
  const buildTimestamp = new Date().toISOString();
  const fileContent = `${buildTimestamp}\n`;
  await Deno.writeTextFile("docs/gen/lastBuild.txt", fileContent);
  console.log(`✅ Data tego budowania zapisana w: ${"docs/gen/lastBuild.txt"}`);

} catch (error) {
  console.error("❌ Błąd podczas budowania:", error);
  // Zakończ proces z kodem błędu, aby poinformować inne narzędzia (np. CI/CD)
  Deno.exit(1);
} finally {
  // Zatrzymaj proces esbuild niezależnie od wyniku
  esbuild.stop();
}
```

## 3. @file ./tasks/docs-serve.ts

```ts
/**
 * @file ./tasks/docs-serve.ts
 * @author https://github.com/j-Cis
 * 
 * @lastmodified 2025-06-12T13:02:17.500Z+02:00
 * @description Server deweloperski.
 */
import { serveDir } from "$deno-http/file-server";
import { fromFileUrl, join, relative  } from "$deno-path";


const rootPath = fromFileUrl(new URL("../", import.meta.url));
const docsPath = `${rootPath}docs`;
const devPath = join(docsPath, "dev");
const lastBuildPath = join(docsPath, "gen", "lastBuild.txt");

// --- Konfiguracja Live Reload ---
const clients = new Set<WebSocket>();

// Zmienna, która śledzi, czy oczekujemy na przebudowanie projektu
let isDevChangePending = false;

// Ta funkcja nie wymaga ŻADNYCH dodatkowych importów.
async function watchForChanges() {
  console.log(`👀 Obserwator plików uruchomiony w '${docsPath}'`);
  const watcher = Deno.watchFs(docsPath);

  for await (const event of watcher) {    
    // Sprawdzamy, czy którykolwiek ze zmienionych plików pasuje do naszej logiki
    let shouldReload = false;
    //let buildCompleted = false;

    for (const path of event.paths) {
      // 1. Zmiana w plikach deweloperskich (`/docs/dev/`)
      if (path.startsWith(devPath)) {
        isDevChangePending = true;
        console.log(`📝 Zmiana w plikach deweloperskich. Oczekiwanie na 'deno task gen'...`);
        continue;
      }

      // 2. Zmiana w pliku `lastBuild.txt`
      if (path === lastBuildPath) {
        if (isDevChangePending) {
          console.log(`✅ Build zakończony. Odświeżam stronę...`);
          isDevChangePending = false;
          shouldReload = true;
          break;
        }
        continue;
      }

      // 3. Zmiana w jakimkolwiek innym pliku (np. CSS, HTML, JSON)
      const relativePath = relative(docsPath, path);
      if (!relativePath.startsWith("dev") && !relativePath.startsWith("gen")) {
        console.log(`🔄 Zmiana w pliku statycznym: ${relativePath}. Odświeżam...`);
        shouldReload = true;
        break;
      }
    }
    // Po sprawdzeniu wszystkich ścieżek, decydujemy, czy wysłać sygnał
    if (shouldReload) {
      for (const socket of clients) {
        if (socket.readyState === WebSocket.OPEN) {
          socket.send("reload");
        }
      }
    }

    /*
    if (event.kind === "modify" || event.kind === "create" || event.kind === "remove") {
      console.log(` Zmiany w plikach: ${event.paths.join(', ')}. Odświeżam...`);
      // Wyślij sygnał "reload" do wszystkich podłączonych klientów
      for (const socket of clients) {
        if (socket.readyState === WebSocket.OPEN) {
          socket.send("reload");
        }
      }
    }
    */
  }
}
watchForChanges().catch(err => console.error("Błąd obserwatora:", err));
// ---------------------------------

Deno.serve({ port: 8008 }, async (req) => {
  const url = new URL(req.url);
  const pathname = url.pathname;

  // 1. Specjalny endpoint dla WebSocket
  if (pathname === "/__live_reload_ws") {
    if (req.headers.get("upgrade") !== "websocket") {
      return new Response("Expected websocket upgrade", { status: 426 });
    }
    const { socket, response } = Deno.upgradeWebSocket(req);
    socket.onopen = () => clients.add(socket);
    socket.onclose = () => clients.delete(socket);
    socket.onerror = (e) => console.error("Błąd WebSocket:", e);
    return response;
  }

  // 2. Serwowanie plików statycznych  
  const response = await serveDir(req, {
    fsRoot: docsPath,
    quiet: true,
  });

  console.log(`[${req.method}] ${pathname} - ${response.status}`);

  // 3. Wstrzyknięcie skryptu Live Reload do plików HTML
  if (response.ok && response.headers.get("content-type")?.includes("text/html")) {
    const originalHtml = await response.text();
    const modifiedHtml = originalHtml.replace(
      "</body>",
      `  <script>
        const socket = new WebSocket(\`ws://\${window.location.host}/__live_reload_ws\`);
        socket.addEventListener('message', (event) => {
          if (event.data === 'reload') {
            console.log('🔄 Otrzymano sygnał odświeżenia z serwera...');
            window.location.reload();
          }
        });
        socket.addEventListener('close', () => console.warn('Połączenie Live Reload zerwane.'));
      </script>
    </body>`
    );

    const headers = new Headers(response.headers);
    headers.set("Cache-Control", "no-store, no-cache, must-revalidate");
    headers.set("Pragma", "no-cache");
    headers.set("Expires", "0");
    headers.delete("content-length");

    return new Response(modifiedHtml, { status: response.status, headers });
  }

  const headers = new Headers(response.headers);
  headers.set("Cache-Control", "no-store");
  return new Response(response.body, { status: response.status, headers });
});

console.log("🚀 Serwer deweloperski uruchomiony na http://localhost:8008");
```

## 4. @file ./docs/index.html

```html
<!--
/**
 * @file ./docs/index.html
 * @author https://github.com/j-Cis
 * 
 * @lastmodified 2025-06-12T13:08:51.934Z+02:00
 * @description Główny plik montowania.
 */
-->
<!DOCTYPE html>
<html lang="pl">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>graph-generator</title>
  <link rel="stylesheet" href="css/reset.css" />
  <link rel="stylesheet" href="css/ui/AccordionFields.css" />
  <link rel="stylesheet" href="css/main.css" />
</head>

<body>
  <main id="root"></main>
  <script type="module" src="gen/main.js"></script>
</body>

</html>
```

## 5. @file ./docs/css/reset.css

```css
/**
 * @file ./docs/css/reset.css
 * @author https://github.com/j-Cis
 * 
 * @lastmodified 2025-06-12T13:10:25.270Z+02:00
 * @description Resetowanie predefiniowanych ustawień różnych przeglądarek.
 */

/* === Nowoczesny Reset CSS === */

/* 1. Użyj bardziej intuicyjnego modelu pudełkowego dla wszystkich elementów.
  Padding i border nie będą już powiększać elementów.
*/
*,
*::before,
*::after {
  box-sizing: border-box;
}

/* 2. Usuń domyślne marginesy.
 */
body,
h1,
h2,
h3,
h4,
p,
ul,
ol,
li,
figure,
figcaption,
blockquote,
dl,
dd {
  margin: 0;
}

/* 3. Ustaw `html` i `body` na pełną wysokość i szerokość okna przeglądarki.
  To jest bezpośrednia odpowiedź na Twoją prośbę.
  Dodatkowo, `line-height` poprawia czytelność tekstu.
*/
html,
body {
  height: 100%;
  width: 100%;
  line-height: 1.5;
  -webkit-font-smoothing: antialiased; /* Lepsze renderowanie czcionek na WebKit */
}

/* 4. Uprość resetowanie stylów list
 */
ul,
ol {
  padding: 0;
  list-style: none;
}

/* 5. Spraw, aby media (obrazki, wideo) były domyślnie responsywne.
  Nie będą "wystawać" poza swój kontener.
*/
img,
picture,
video,
canvas,
svg {
  display: block;
  max-width: 100%;
}

/* 6. Zapewnij, aby elementy formularzy dziedziczyły style czcionek.
  Dzięki temu przyciski, pola tekstowe itp. będą wyglądać spójnie z resztą tekstu.
*/
input,
button,
textarea,
select {
  font: inherit;
}

/* 7. Usuń domyślne dekoracje tekstu z linków.
 */
a {
  text-decoration: none;
  color: inherit;
}

/* 8. Unikaj przepełnienia tekstu (text overflow).
 */
p,
h1,
h2,
h3,
h4,
h5,
h6 {
  overflow-wrap: break-word;
}

/* 9. Stwórz kontekst "stackowania" na elemencie root aplikacji.
  To bardziej zaawansowana technika, która zapobiega problemom z `z-index` w przyszłości.
*/
#root {
  isolation: isolate;
  height: 100%; /* Upewnij się, że kontener aplikacji również zajmuje pełną wysokość */
  width: 100%;
}
```

## 6.  @file ./docs/css/ui/AccordionFields.css

```css
/**
 * @file ./docs/css/ui/AccordionFields.css
 * @author https://github.com/j-Cis
 * 
 * @lastmodified 2025-06-12T13:13:11.138Z+02:00
 * @description Główne style dla komponentu AccordionFields.
 */

/* --- Styl dla Kontrolera (Pilota) --- */

.af-pilot-wrapper {
  /* Możesz pozycjonować ten wrapper absolutnie, gdziekolwiek chcesz na stronie, np. */
  position: fixed;
  bottom: 20px;
  right: 20px;
  z-index: 1000;
  display: flex;
  flex-direction: row-reverse;
  gap: 20px;
}

.af-pilot-rotate,
.af-pilot-trigger {
  width: 75px;
  height: 75px;
  border-radius: 50%;
  opacity: 50%;
  font-size: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.af-pilot-rotate,
.af-pilot-trigger,
.af-select-btn,
.af-select-split-btn {
  border: 1px solid rgba(0, 0, 0, 0.2);
  background-color: rgba(255, 255, 255, 0.7);
  backdrop-filter: blur(5px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  transition: transform 0.2s ease;
  cursor: pointer;
}
.af-select-btn,
.af-select-split-btn {
  border-radius: 10px;
  font-size: 18px;
  min-height: 45px;
}

.af-pilot-rotate:hover,
.af-pilot-trigger:hover,
.af-select-btn:hover,
.af-select-split-btn:hover {
  transform: scale(1.1);
}
.af-pilot-rotate:active,
.af-pilot-trigger:active,
.af-select-btn:active,
.af-select-split-btn:active {
  transform: scale(1.1);
  background-color: rgba(251 245 113 / 0.7);
  transition: transform 0.8s ease;
}

.af-controls-panel {
  position: absolute;
  bottom: calc(100% + 20px); /* Panel pojawia się nad przyciskiem */
  right: 0;
  width: 265px;
  background-color: #fff;
  border-radius: 8px;
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
  padding: 12px;
  border: 1px solid #eee;
  animation: af-fade-in 0.2s ease-out;
}

.af-controls-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 10px;
  border-bottom: 1px solid #f0f0f0;
  padding-bottom: 8px;
}

.af-controls-header h3 {
  margin: 0;
  font-size: 16px;
}

.af-close-btn {
  background: none;
  border: none;
  font-size: 20px;
  cursor: pointer;
  color: #888;
}

.af-controls-panel ul {
  list-style: none;
  padding: 0;
  margin: 0;
}
.af-controls-panel li {
  padding: 8px;
  border-radius: 4px;
}
.af-controls-panel li:hover {
  background-color: #f5f5f5;
}

@keyframes af-fade-in {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* --- Styl dla Kontenera Paneli --- */

.af-container {
  width: 100%;
  height: 100%;
  display: flex;
  background-color: #fafafa;
  border: 1px dashed #ddd;
  padding: 1rem;
  box-sizing: border-box;
}

.af-row {
  flex-direction: row;
}

.af-col {
  flex-direction: column;
}

.af-button-grid {
  display: grid;
  grid-template-columns: 1fr;
  gap: 5px;
}

.af-button-grid-col2 {
  display: grid;
  grid-template-columns: 1fr 1fr 1fr 1fr 1fr;
  gap: 10px;
}

.af-title-group {
  display: flex;
  width: 100%;
}

.af-select-btn {
  flex-grow: 1;
  text-align: left;
  /* ... inne style przycisku */
}

.af-select-split-btn {
  flex-shrink: 0;
  padding: 8px 10px;
  margin-left: 5px;
  /* ... inne style przycisku */
}

.af-panel {
  overflow: auto; /* Paski przewijania w razie potrzeby */
  padding: 1em;
  box-sizing: border-box;
}

.af-panel-single {
  width: 100%;
  height: 100%;
}

.af-visual-divider {
  background-color: #e0e0e0;
}

.af-container.af-row .af-visual-divider {
  width: 2px;
  height: 100%;
}

.af-container.af-col .af-visual-divider {
  width: 100%;
  height: 2px;
}
```

## 7. @file ./docs/css/main.css

```css
/**
 * @file ./docs/css/main.css
 * @author https://github.com/j-Cis
 * 
 * @lastmodified 2025-06-12T13:12:07.028Z+02:00
 * @description Główne stylizowanie.
 */

.non-select {
  -webkit-user-select: none; /* Safari */
  -ms-user-select: none; /* IE 10 and IE 11 */
  user-select: none; /* Standard syntax */
}

```

## 8.  @file ./docs/dev/style/types.ts

```ts
/**
 * @file ./docs/dev/style/types.ts
 * @author https://github.com/j-Cis
 * 
 * @lastmodified 2025-06-12T13:16:36.109Z+02:00
 * @description typy dla dynamicznego css.
 */

import { JSX } from "$tsx-preact";
export type CustomCSSProperties = JSX.CSSProperties & {
  [key: `--${string}`]: string | number;
};
```

## 9. @file ./docs/dev/main.tsx

```tsx
/**
 * @file ./docs/dev/main.tsx
 * @author https://github.com/j-Cis
 *
 * @lastmodified 2025-06-12T13:15:20.370Z+02:00
 * @description Główny plik.
 */

/** @jsxRuntime automatic */
/** @jsxImportSource $tsx-preact */

import { render } from "$tsx-preact";
import {
  AccordionField,
  AccordionFields,
  AccordionFieldsPilot,
} from "./ui/AccordionFields.tsx";
import PageEduGraphs from "./pages/EduGraphs.tsx";
import PageEduDot from "./pages/EduDot.tsx";
import PageDotWriter from "./pages/DotWriter.tsx";
import PageDotRender from "./pages/DotRender.tsx";
import PageDotInsert from "./pages/DotInsert.tsx";
import PageAboutThis from "./pages/AboutThis.tsx";

function LayoutStart() {
  const ANCHOR_ID = "graph-sections";

  return (
    <>
      <AccordionFieldsPilot
        forAnchor={ANCHOR_ID}
        showAnchor={false}
      />

      <AccordionFields
        anchorTag={ANCHOR_ID}
        firstViewID={[3, 4]}
      >
        <AccordionField viewID={0} title="o grafach..">
          <PageEduGraphs />
        </AccordionField>
        <AccordionField viewID={1} title="o dot..">
          <PageEduDot />
        </AccordionField>

        <AccordionField viewID={2} title="Wstaw..">
          <PageDotInsert />
        </AccordionField>

        <AccordionField viewID={3} title="Pisz..">
          <PageDotWriter />
        </AccordionField>

        <AccordionField viewID={4} title="Efekt..">
          <PageDotRender />
        </AccordionField>

        <AccordionField viewID={5} title="o tym..">
          <PageAboutThis />
        </AccordionField>
      </AccordionFields>
    </>
  );
}

// Bezpieczny montaż aplikacji
const rootElement = document.getElementById("root");

if (rootElement) {
  render(<LayoutStart />, rootElement);
} else {
  console.error(
    'Nie znaleziono elementu startowego #root. Upewnij się, że w pliku HTML istnieje element <div id="root"></div>.',
  );
}
```

## 10.a. @file ./docs/dev/core/state-accordion.ts

```ts
/**
 * @file ./docs/dev/core/state-accordion.ts
 * @author https://github.com/j-Cis
 * 
 * @lastmodified 2025-06-12T13:19:01.961Z+02:00
 * @description kontrolowanie stanu związane z komponentem AccordionFields.
 */

import { signal, Signal } from "$tsx-preact-signal";

// --- Definicja Struktury Stanu ---

/**
 * Definiuje, jak wygląda obiekt stanu dla pojedynczej instancji
 * komponentu AccordionFields.
 */
export interface AccordionState {
  // Czy cały interfejs pilota jest otwarty? Wracamy do tego prostego stanu.
  isOpen: boolean;
  // Który widok jest aktywny WEWNĄTRZ otwartego panelu?
  activePanel: 'main' | 'ratio';
  // Lista tytułów wszystkich dostępnych pól (paneli).
  // To jest kluczowe, aby pilot wiedział, jakie przyciski wyświetlić.
  fieldTitles: string[];
  // W jakim trybie jest akordeon: 'single' (jeden panel) czy 'split' (dwa panele).
  mode: 'single' | 'split';
  // Który etap wyboru w trybie split jest aktywny.
  splitStep: 'idle' | 'selecting_second' | 'selecting_ratio';
  // Tablica z tytułami widocznych paneli.
  // np. ['a1', null] dla trybu single, ['a1', 'a2'] dla trybu split.
  visiblePanels: [string | null, string | null];
  // Stosunek podziału w trybie split, np. '1:1'.
  ratio: string;
  arrow: "ROW" | "COL"
}

// --- Globalny Magazyn Stanu ---

/**
 * Główny, globalny magazyn przechowujący stany wszystkich akordeonów na stronie.
 * Używamy Map, gdzie kluczem jest unikalny `anchorTag` (np. "aa77"),
 * a wartością jest sygnał (Signal) zawierający obiekt stanu dla tego akordeonu.
 * * Dlaczego `Signal<Map<...>>`? Aby komponenty mogły reagować na dodawanie
 * lub usuwanie całych instancji akordeonów.
 */
const accordionStore = signal(new Map<string, Signal<AccordionState>>());

// Definiujemy typ dla pól przekazywanych do funkcji rejestrującej
type FieldData = {
  title: string;
  viewID: number;
};

// --- Funkcje Pomocnicze (Publiczne API Naszego Magazynu) ---

/**
 * Rejestruje nową instancję akordeonu w globalnym magazynie.
 * Komponent <AccordionFields> wywoła tę funkcję, gdy zostanie zamontowany.
 * @param anchorTag Unikalny identyfikator dla pary Kontroler-Akordeon.
 * @param titles Tablica z tytułami wszystkich pól-dzieci, które przekazał użytkownik.
 */
function registerAccordion(
  anchorTag: string, 
  fields: FieldData[], 
  initialArrow: "ROW" | "COL",
  firstViewID: [number] | [number, number] | undefined
): void {
  // Sprawdzamy, czy instancja o tym anchorTag już nie istnieje
  if (accordionStore.value.has(anchorTag) || fields.length === 0) {
    console.log(`AccordionFields with anchorTag "${anchorTag}" is already registered.`);
    return;
  }
  let initialMode: 'single' | 'split' = 'single';
  let initialVisiblePanels: [string | null, string | null] = [fields[0].title, null];

  // Logika ustawiania stanu na podstawie `firstViewID`
  if (firstViewID) {
    if (firstViewID.length === 2) { // Tryb dzielony
      const panel1 = fields.find(f => f.viewID === firstViewID[0]);
      const panel2 = fields.find(f => f.viewID === firstViewID[1]);
      if (panel1 && panel2) {
        initialMode = 'split';
        initialVisiblePanels = [panel1.title, panel2.title];
      }
    } else if (firstViewID.length === 1) { // Tryb pojedynczy
      const panel = fields.find(f => f.viewID === firstViewID[0]);
      if (panel) {
        initialMode = 'single';
        initialVisiblePanels = [panel.title, null];
      }
    }
  }

  // Tworzymy sygnał z domyślnym, początkowym stanem dla tego akordeonu.
  const initialState: AccordionState = {
    isOpen: false,
    activePanel: 'main', // Domyślnie pokazujemy główny widok
    fieldTitles: fields.map(f => f.title), // Wyciągamy same tytuły // Pilot od razu wie, jakie ma panele!
    mode: initialMode,
    splitStep: 'idle', // Domyślny stan etapu
    visiblePanels: initialVisiblePanels,
    ratio: '1:1',
    arrow: initialArrow, // Ustawiamy początkowy kierunek
  };

  const newStateSignal = signal(initialState);

  // Aktualizujemy globalną mapę, dodając nowy wpis.
  // Używamy spread (...) aby stworzyć nową mapę, co jest wymagane przez Signals
  // do wykrycia zmiany i poinformowania subskrybentów.
  accordionStore.value = new Map([...accordionStore.value, [anchorTag, newStateSignal]]);
}

/**
 * Wyrejestrowuje instancję akordeonu z globalnego magazynu.
 * Komponent <AccordionFields> wywoła tę funkcję, gdy zostanie odmontowany.
 * @param anchorTag Identyfikator akordeonu do usunięcia.
 */
function unregisterAccordion(anchorTag: string): void {
  const newStore = new Map(accordionStore.value);
  if (newStore.delete(anchorTag)) {
    accordionStore.value = newStore;
  }
}

/**
 * Zwraca sygnał stanu dla konkretnej instancji akordeonu.
 * Zarówno <AccordionFields> jak i <AccordionFieldsPilot> użyją tej funkcji,
 * aby uzyskać dostęp do swojego stanu i móc na niego reagować.
 * @param anchorTag Identyfikator akordeonu.
 * @returns Sygnał (Signal) ze stanem lub `undefined`, jeśli nie znaleziono.
 */
function getAccordionState(anchorTag: string): Signal<AccordionState> | undefined {
  return accordionStore.value.get(anchorTag);
}


export {
  registerAccordion,
  unregisterAccordion,
  getAccordionState
};
```

## 10.b. @file ./docs/dev/ui/AccordionField.tsx

```tsx
/**
 * @file ./docs/dev/ui/AccordionField.tsx
 * @author https://github.com/j-Cis
 *
 * @lastmodified 2025-06-12T13:20:17.608Z+02:00
 * @description Komponentem pojedynczego panelu AccordionField w AccordionFields.
 */

/** @jsxRuntime automatic */
/** @jsxImportSource $tsx-preact */
import { ComponentChildren, VNode } from "$tsx-preact";

// Definicja propsów. Każde pole musi mieć tytuł.
type AccordionFieldProps = {
  title: string;
  viewID: number;
  children: ComponentChildren;
};

/**
 * Komponent reprezentujący pojedynczy panel (pole) w akordeonie.
 * Jego jedynym zadaniem jest przechowywanie `title` i `children`.
 * Nie renderuje niczego bezpośrednio - jest tylko nośnikiem danych dla rodzica.
 */
function AccordionField(
  { children }: AccordionFieldProps,
): VNode | null {
  // Zwracamy dzieci wewnątrz fragmentu. Rodzic <AccordionFields>
  // odczyta propsy i zdecyduje, co z tym zrobić.
  return <>{children}</>;
}

export type { AccordionFieldProps };
export { AccordionField };
```

## 10.c. @file ./docs/dev/ui/AccordionFields.tsx

```tsx
/**
 * @file ./docs/dev/ui/AccordionFields.tsx
 * @author https://github.com/j-Cis
 *
 * @lastmodified 2025-06-12T13:21:12.598Z+02:00
 * @description Komponentem zbiorczego AccordionFields dla paneli AccordionField.
 */

/** @jsxRuntime automatic */
/** @jsxImportSource $tsx-preact */
import { ComponentChildren, VNode } from "$tsx-preact";
import { useEffect, useMemo } from "$tsx-preact/hooks";
import {
  getAccordionState,
  registerAccordion,
  unregisterAccordion,
} from "../core/state-accordion.ts";
import { AccordionField, AccordionFieldProps } from "./AccordionField.tsx";
import { CustomCSSProperties } from "../style/types.ts";

type ContainerProps = {
  anchorTag: string;
  initialDivider?: "ROW" | "COL";
  firstViewID?: [number] | [number, number];
  children: ComponentChildren;
};

/**
 * Pomocnicza funkcja do parsowania proporcji (np. '2:1') na wartości flex.
 * @param ratio - String w formacie 'number:number'.
 * @returns Tablica z dwiema wartościami liczbowymi.
 */
function parseRatio(ratio: string): [number, number] {
  const parts = ratio.split(":").map(Number);
  if (parts.length === 2 && !isNaN(parts[0]) && !isNaN(parts[1])) {
    return [parts[0], parts[1]];
  }
  // Domyślna, bezpieczna wartość w razie błędu
  return [1, 1];
}

/**
 * Główny kontener, który renderuje widoczne panele.
 */
function AccordionFields({
  anchorTag,
  initialDivider = "ROW",
  firstViewID,
  children,
}: ContainerProps): VNode {
  // Pobieramy sygnał stanu dla tej instancji akordeonu.
  const state = getAccordionState(anchorTag);

  // Używamy `useMemo`, aby wyodrębnić tytuły i zawartość z dzieci
  // tylko raz, chyba że dzieci się zmienią.
  const fields = useMemo(() => {
    const extracted: { title: string; viewID: number; content: VNode }[] = [];
    const childrenArray = Array.isArray(children) ? children : [children];

    for (const child of childrenArray) {
      if (
        child && typeof child === "object" && "type" in child &&
        child.type === AccordionField
      ) {
        const props = child.props as AccordionFieldProps;
        extracted.push({
          title: props.title,
          viewID: props.viewID,
          content: child,
        });
      }
    }
    return extracted;
  }, [children]);

  // Efekt do rejestracji i wyrejestrowania w globalnym magazynie.
  useEffect(() => {
    // const titles = fields.map((f) => f.title);
    if (fields.length > 0) {
      registerAccordion(anchorTag, fields, initialDivider, firstViewID);
    }

    // Funkcja czyszcząca - wywoływana, gdy komponent jest odmontowywany.
    return () => {
      unregisterAccordion(anchorTag);
    };
  }, [anchorTag, fields, initialDivider, firstViewID]); // Uruchom ponownie, jeśli zmieni się anchor lub lista pól.

  // Jeśli stan nie jest jeszcze dostępny, nie renderuj nic.
  if (!state) {
    return <div class="af-container af-loading">Inicjalizacja...</div>;
  }

  const renderContent = () => {
    // Tryb Dzielony (Split)
    if (
      state.value.mode === "split" && state.value.visiblePanels[0] &&
      state.value.visiblePanels[1]
    ) {
      const [title1, title2] = state.value.visiblePanels;
      const panel1 = fields.find((f) => f.title === title1);
      const panel2 = fields.find((f) => f.title === title2);

      const [flex1, flex2] = parseRatio(state.value.ratio);

      const style1: CustomCSSProperties = { flex: flex1 };
      const style2: CustomCSSProperties = { flex: flex2 };

      if (!panel1 || !panel2) {
        return <div>Błąd: Nie można znaleźć jednego z paneli.</div>;
      }

      return (
        <>
          <div class="af-panel" style={style1}>{panel1.content}</div>
          {/* Opcjonalnie: można dodać wizualny separator między panelami */}
          <div class="af-visual-divider"></div>
          <div class="af-panel" style={style2}>{panel2.content}</div>
        </>
      );
    }

    // Tryb Pojedynczy (Single) - domyślny
    const firstVisibleTitle = state.value.visiblePanels[0];
    const panelToShow = fields.find((f) => f.title === firstVisibleTitle);

    return (
      <div class="af-panel af-panel-single">
        {panelToShow
          ? panelToShow.content
          : <div>Wybierz panel do wyświetlenia...</div>}
      </div>
    );
  };

  return (
    <div class={`af-container af-${state.value.arrow.toLowerCase()}`}>
      {renderContent()}
    </div>
  );
}

export { AccordionField, AccordionFields };
export { AccordionFieldsPilot } from "./AccordionFieldsPilot.tsx";
```

## 10.d. @file ./docs/dev/ui/AccordionFieldsPilot.tsx

```tsx
/**
 * @file ./docs/dev/ui/AccordionFieldsPilot.tsx
 * @author https://github.com/j-Cis
 *
 * @lastmodified 2025-06-12T13:23:07.062Z+02:00
 * @description Komponentem sterownika do komponentów AccordionFields i AccordionField.
 */

/** @jsxRuntime automatic */
/** @jsxImportSource $tsx-preact */
import { VNode } from "$tsx-preact";
import { getAccordionState } from "../core/state-accordion.ts";

type PilotProps = {
  forAnchor: string;
  showAnchor?: boolean;
};

// Definicja dostępnych proporcji dla trybu dzielonego
const RATIOS = [
  "1:1",
  "2:1",
  "1:2",
  "3:1",
  "1:3",
  "3:2",
  "2:3",
  "4:1",
  "1:4",
  "3:4",
  "4:3",
];

/**
 * Komponent "pilota", który kontroluje stan powiązanego akordeonu.
 */
export function AccordionFieldsPilot(
  { forAnchor, showAnchor = true }: PilotProps,
): VNode {
  // Pobieramy sygnał stanu dla akordeonu, którym mamy sterować.
  const state = getAccordionState(forAnchor);

  // Jeśli stan dla danego 'anchor' nie istnieje (jeszcze), nie renderujemy nic.
  if (!state) {
    // Ta wiadomość jest normalna przy pierwszym renderowaniu
    // console.warn(`[Pilot] No state found for anchor: ${forAnchor}`);
    // deno-lint-ignore jsx-no-useless-fragment
    return <></>;
  }

  // Główny przełącznik, który otwiera i zamyka cały interfejs pilota
  const handleTogglePilot = () => {
    const nextIsOpen = !state.value.isOpen;
    state.value = {
      ...state.value,
      isOpen: nextIsOpen,
      // Przy otwieraniu ZAWSZE pokazuj panel główny, resetując wybór
      activePanel: nextIsOpen ? "main" : state.value.activePanel,
      splitStep: !nextIsOpen ? "idle" : state.value.splitStep,
    };
  };

  // Zmienia kierunek podziału
  const handleToggleArrow = () => {
    state.value = {
      ...state.value,
      arrow: state.value.arrow === "ROW" ? "COL" : "ROW",
    };
  };

  // Ustawia, że wewnątrz panelu chcemy widzieć wybór proporcji
  const showRatioSelector = () => {
    state.value = { ...state.value, activePanel: "ratio" };
  };

  /**
   * Finalizuje wybór, ustawia proporcje i zamyka menu.
   * @param ratio Wybrany stosunek, np. '1:1'.
   */
  const handleSelectRatio = (ratio: string) => {
    state.value = {
      ...state.value,
      ratio: ratio,
      isOpen: false,
      splitStep: "idle",
    };
  };

  /**
   * Obsługuje kliknięcie na nazwę panelu w menu pilota.
   * Ustawia akordeon w tryb 'single' i pokazuje wybrany panel.
   * @param title Tytuł panelu do wyświetlenia.
   */
  const handleSelectPanel = (title: string) => {
    state.value = {
      ...state.value,
      mode: "single",
      splitStep: "idle",
      visiblePanels: [title, null],
      isOpen: false,
    };
  };

  /**
   * Rozpoczyna proces wyboru widoku dzielonego.
   * @param title Tytuł pierwszego panelu, który został wybrany.
   */
  const handleStartSplit = (title: string) => {
    state.value = {
      ...state.value,
      mode: "split",
      splitStep: "selecting_second",
      visiblePanels: [title, null],
    };
  };

  /**
   * Obsługuje wybór drugiego panelu w trybie dzielonym.
   * @param title Tytuł drugiego wybranego panelu.
   */
  const handleSelectSecondPanel = (title: string) => {
    const firstPanel = state.value.visiblePanels[0];
    state.value = {
      ...state.value,
      splitStep: "selecting_ratio", // Przejdź do etapu wyboru proporcji
      visiblePanels: [firstPanel, title], // Zapisz oba wybrane panele
    };
  };

  // --- Funkcje renderujące poszczególne widoki panelu ---

  const renderPanelContent = () => {
    // Widok wyboru proporcji
    if (state.value.activePanel === "ratio") {
      const [panel1, panel2] = state.value.visiblePanels;
      return (
        <div>
          <p class="non-select">
            Zmień proporcje dla<br /> [ <strong>{panel1}</strong> ] i{"  "}[
            {" "}
            <strong>{panel2}</strong> ]:
          </p>
          <div class="af-button-grid-col2">
            {RATIOS.map((ratio) => (
              <button
                type="button"
                key={ratio}
                class="af-select-btn"
                onClick={() => handleSelectRatio(ratio)}
              >
                {ratio}
              </button>
            ))}
          </div>
        </div>
      );
    }

    // Widok główny (wieloetapowy)
    if (state.value.splitStep === "selecting_second") {
      const firstPanel = state.value.visiblePanels[0];
      const availablePanels = state.value.fieldTitles.filter((t) =>
        t !== firstPanel
      );
      return (
        <div>
          <p class="non-select">
            Panel wybrany: [ <strong>{firstPanel}</strong> ].
          </p>
          <p class="non-select">
            Wybierz drugi panel do pary:
          </p>
          <div class="af-button-grid">
            {availablePanels.map((title) => (
              <button
                type="button"
                key={title}
                class="af-select-btn"
                onClick={() => handleSelectSecondPanel(title)}
              >
                {title}
              </button>
            ))}
          </div>
        </div>
      );
    }
    if (state.value.splitStep === "selecting_ratio") {
      const [panel1, panel2] = state.value.visiblePanels;
      return (
        <div>
          <p class="non-select">
            Ustaw proporcje dla wybranych paneli:<br />
            [ <strong>{panel1}</strong> ] i [ <strong>{panel2}</strong> ]:
          </p>
          <div class="af-button-grid-col2">
            {RATIOS.map((ratio) => (
              <button
                type="button"
                key={ratio}
                class="af-select-btn"
                onClick={() => handleSelectRatio(ratio)}
              >
                {ratio}
              </button>
            ))}
          </div>
        </div>
      );
    }
    return (
      <div>
        <p class="non-select">Wybierz [ panel |..] do wyświetlenia:</p>
        <div class="af-button-grid">
          {state.value.fieldTitles.map((title) => (
            <div key={title} class="af-title-group">
              <button
                type="button"
                class="af-select-btn"
                onClick={() =>
                  handleSelectPanel(title)}
              >
                {title}
              </button>
              <button
                type="button"
                class="af-select-split-btn"
                onClick={() =>
                  handleStartSplit(title)}
                title={`Wybierz "${title}" jako pierwszy panel`}
              >
                |..
              </button>
            </div>
          ))}
        </div>
      </div>
    );
  };

  return (
    <div class="af-pilot-wrapper">
      {/* Główny przycisk-wyzwalacz */}
      <button
        type="button"
        class="af-pilot-trigger"
        onClick={handleTogglePilot}
        title="Otwórz kontroler paneli"
      >
        ☰
      </button>

      {/* Przyciski funkcyjne widoczne tylko w trybie 'split' */}
      {state.value.isOpen && state.value.mode === "split" && (
        <>
          <button
            type="button"
            class="af-pilot-rotate"
            onClick={handleToggleArrow}
            title="Obróć"
          >
            {state.value.arrow === "COL" ? "↵" : "↴"}
          </button>
          <button
            type="button"
            class="af-pilot-rotate"
            onClick={showRatioSelector}
            style={state.value.arrow === "COL"
              ? { transform: "rotate(90deg)" }
              : {}}
            title="Zmień proporcje"
          >
            ◫
          </button>
        </>
      )}

      {/* Warunkowe renderowanie paneli na podstawie stanu `openPanel` */}
      {state.value.isOpen && (
        <div class="af-controls-panel">
          <div class="af-controls-header">
            <h3>Sterowanie wyświetlaniem.{showAnchor && ({ forAnchor })}</h3>
            <button
              type="button"
              onClick={handleTogglePilot}
              class="af-close-btn"
              title="Zamknij"
            >
              ×
            </button>
          </div>
          {renderPanelContent()}
        </div>
      )}
    </div>
  );
}
```

## 11.a. @file ./docs/dev/pages/AboutThis.tsx

```tsx
/**
 * @file ./docs/dev/pages/AboutThis.tsx
 * @author https://github.com/j-Cis
 *
 * @lastmodified 2025-06-12T13:28:31.401Z+02:00
 * @description Komponentem sekcji tematycznej AboutThis.
 */

/** @jsxRuntime automatic */
/** @jsxImportSource $tsx-preact */

export default function PageAboutThis() {
  return (
    <div>
      <h3>Zawartość panelu 6 PageAboutThis</h3>
      <p>Tutaj znajdują się opcje konfiguracji.</p>
      <label>
        Opcja A: <input type="checkbox" />
      </label>
    </div>
  );
}

```

## 11.b. @file ./docs/dev/pages/EduGraphs.tsx

```tsx
/**
 * @file ./docs/dev/pages/EduGraphs.tsx
 * @author https://github.com/j-Cis
 *
 * @lastmodified 2025-06-12T13:31:53.000Z+02:00
 * @description Komponentem sekcji tematycznej EduGraphs.
 */

/** @jsxRuntime automatic */
/** @jsxImportSource $tsx-preact */

export default function PageEduGraphs() {
  return (
    <div>
      <h3>Zawartość panelu 1 PageEduGraphs</h3>
      <p>Tutaj znajdują się opcje konfiguracji.</p>
      <label>
        Opcja A: <input type="checkbox" />
      </label>
    </div>
  );
}

```

## 11.c. @file ./docs/dev/pages/EduDot.tsx

```tsx
/**
 * @file ./docs/dev/pages/EduDot.tsx
 * @author https://github.com/j-Cis
 *
 * @lastmodified 2025-06-12T13:31:24.942Z+02:00
 * @description Komponentem sekcji tematycznej EduDot.
 */

/** @jsxRuntime automatic */
/** @jsxImportSource $tsx-preact */

export default function PageEduDot() {
  return (
    <div>
      <h3>Zawartość panelu 2 PageEduDot</h3>
      <p>Tutaj znajdują się opcje konfiguracji.</p>
      <label>
        Opcja A: <input type="checkbox" />
      </label>
    </div>
  );
}

```

## 11.d. @file ./docs/dev/pages/DotWriter.tsx

```tsx
/**
 * @file ./docs/dev/pages/DotWriter.tsx
 * @author https://github.com/j-Cis
 *
 * @lastmodified 2025-06-12T13:30:39.314Z+02:00
 * @description Komponentem sekcji tematycznej DotWriter.
 */

/** @jsxRuntime automatic */
/** @jsxImportSource $tsx-preact */

export default function PageDotWriter() {
  return (
    <div>
      <h3>Zawartość panelu 4 PageDotWriter</h3>
      <p>Tutaj znajdują się opcje konfiguracji.</p>
      <label>
        Opcja A: <input type="checkbox" />
      </label>
    </div>
  );
}

```

## 11.e. @file ./docs/dev/pages/DotInsert.tsx

```tsx
/**
 * @file ./docs/dev/pages/DotInsert.tsx
 * @author https://github.com/j-Cis
 *
 * @lastmodified 2025-06-12T13:29:20.880Z+02:00
 * @description Komponentem sekcji tematycznej DotInsert.
 */

/** @jsxRuntime automatic */
/** @jsxImportSource $tsx-preact */

export default function PageDotInsert() {
  return (
    <div>
      <h3>Zawartość panelu 3 PageDotInsert</h3>
      <p>Tutaj znajdują się opcje konfiguracji.</p>
      <label>
        Opcja A: <input type="checkbox" />
      </label>
    </div>
  );
}

```

## 11.f. @file ./docs/dev/pages/DotRender.tsx

```tsx
/**
 * @file ./docs/dev/pages/DotRender.tsx
 * @author https://github.com/j-Cis
 *
 * @lastmodified 2025-06-12T13:29:58.528Z+02:00
 * @description Komponentem sekcji tematycznej DotRender.
 */

/** @jsxRuntime automatic */
/** @jsxImportSource $tsx-preact */

export default function PageDotRender() {
  return (
    <div>
      <h3>Zawartość panelu 5 PageDotRender</h3>
      <p>Tutaj znajdują się opcje konfiguracji.</p>
      <label>
        Opcja A: <input type="checkbox" />
      </label>
    </div>
  );
}

```

---
---
---
---
